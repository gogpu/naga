#include <metal_stdlib>
#include <simd/simd.h>

using metal::uint;

// Safe division helper (handles zero divisor)
template <typename T, typename D>
T _naga_div(T lhs, D rhs) {
    D nz = D(rhs != D(0));
    return lhs / (nz * rhs + D(!nz));
}

// Safe modulo helper (handles zero divisor)
template <typename T, typename D>
T _naga_mod(T lhs, D rhs) {
    D nz = D(rhs != D(0));
    return lhs % (nz * rhs + D(!nz));
}

int classify(int x) {
    int result = int();
    
    switch (x) {
        case 0:
            result = 0;
            break;
        case 1:
            result = 1;
            break;
        case 2:
            result = 1;
            break;
        case 3:
            result = 2;
            break;
        case 4:
            result = 2;
            break;
        case 5:
            result = 2;
            break;
        default:
            result = -(1);
            break;
    }
    return result;
}

uint switch_with_return(uint x) {
    switch (x) {
        case 0u:
            return 100u;
            break;
        case 1u:
            return 200u;
            break;
        default:
            return 0u;
            break;
    }
}

int nested_switch(int a, int b) {
    int result = 0;
    
    switch (a) {
        case 1:
            switch (b) {
                case 10:
                    result = 110;
                    break;
                default:
                    result = 100;
                    break;
            }
            break;
        default:
            result = 0;
            break;
    }
    return result;
}

kernel void main_() {
    int _fc1 = classify(3);
    uint _fc3 = switch_with_return(1u);
    int _fc6 = nested_switch(1, 10);
}

