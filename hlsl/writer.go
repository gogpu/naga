// Copyright 2025 The GoGPU Authors
// SPDX-License-Identifier: MIT

package hlsl

import (
	"fmt"
	"strings"

	"github.com/gogpu/naga/ir"
)

// nameKey identifies an IR entity for name lookup.
type nameKey struct {
	kind    nameKeyKind
	handle1 uint32
	handle2 uint32
}

// nameKeyKind identifies the type of IR entity.
type nameKeyKind uint8

const (
	nameKeyType nameKeyKind = iota
	nameKeyStructMember
	nameKeyConstant
	nameKeyGlobalVariable
	nameKeyFunction
	nameKeyFunctionArgument
	nameKeyEntryPoint
	nameKeyLocal
)

// Writer generates HLSL source code from IR.
type Writer struct {
	module  *ir.Module
	options *Options

	// Output buffer
	out strings.Builder

	// Current indentation level
	indent int

	// Name management
	names map[nameKey]string
	namer *namer

	// Type tracking
	typeNames map[ir.TypeHandle]string

	// Function context (set during function writing)
	currentFunction   *ir.Function
	currentFuncHandle ir.FunctionHandle
	localNames        map[uint32]string
	namedExpressions  map[ir.ExpressionHandle]string

	// Output tracking
	entryPointNames     map[string]string
	registerBindings    map[string]string
	helperFunctions     []string
	usedFeatures        FeatureFlags
	requiredShaderModel ShaderModel

	// Helper function flags
	needsModHelper bool
	needsDivHelper bool
	needsAbsHelper bool
}

// newWriter creates a new HLSL writer.
func newWriter(module *ir.Module, options *Options) *Writer {
	return &Writer{
		module:              module,
		options:             options,
		names:               make(map[nameKey]string),
		namer:               newNamer(),
		typeNames:           make(map[ir.TypeHandle]string),
		entryPointNames:     make(map[string]string),
		registerBindings:    make(map[string]string),
		namedExpressions:    make(map[ir.ExpressionHandle]string),
		requiredShaderModel: options.ShaderModel,
	}
}

// String returns the generated HLSL source code.
func (w *Writer) String() string {
	return w.out.String()
}

// writeModule generates HLSL code for the entire module.
func (w *Writer) writeModule() error {
	// 1. Write header comment
	w.writeHeader()

	// 2. Register all names
	if err := w.registerNames(); err != nil {
		return err
	}

	// 3. Write type definitions (structs)
	if err := w.writeTypes(); err != nil {
		return err
	}

	// 4. Write constants
	if err := w.writeConstants(); err != nil {
		return err
	}

	// 5. Write global variables (cbuffers, textures, etc.)
	if err := w.writeGlobalVariables(); err != nil {
		return err
	}

	// 6. Write helper functions if needed
	w.writeHelperFunctions()

	// 7. Write regular functions
	if err := w.writeFunctions(); err != nil {
		return err
	}

	// 8. Write entry points
	return w.writeEntryPoints()
}

// writeHeader writes an optional header comment.
func (w *Writer) writeHeader() {
	w.writeLine("// Generated by naga HLSL backend")
	w.writeLine("// Target: %s", w.options.ShaderModel.String())
	w.writeLine("")
}

// registerNames assigns unique names to all IR entities.
//
//nolint:gocognit // Name registration requires handling all IR entity types
func (w *Writer) registerNames() error {
	// Register type names
	for handle := range w.module.Types {
		typ := &w.module.Types[handle]
		var baseName string
		if typ.Name != "" {
			baseName = typ.Name
		} else {
			baseName = fmt.Sprintf("type_%d", handle)
		}
		name := w.namer.call(baseName)
		w.names[nameKey{kind: nameKeyType, handle1: uint32(handle)}] = name //nolint:gosec // G115: handle is valid slice index
		w.typeNames[ir.TypeHandle(handle)] = name                           //nolint:gosec // G115: handle is valid slice index

		// Register struct member names
		if st, ok := typ.Inner.(ir.StructType); ok {
			for memberIdx, member := range st.Members {
				memberName := member.Name
				if memberName == "" {
					memberName = fmt.Sprintf("member_%d", memberIdx)
				}
				w.names[nameKey{kind: nameKeyStructMember, handle1: uint32(handle), handle2: uint32(memberIdx)}] = Escape(memberName) //nolint:gosec // G115: handle is valid slice index
			}
		}
	}

	// Register constant names
	for handle := range w.module.Constants {
		constant := &w.module.Constants[handle]
		var baseName string
		if constant.Name != "" {
			baseName = constant.Name
		} else {
			baseName = fmt.Sprintf("const_%d", handle)
		}
		name := w.namer.call(baseName)
		w.names[nameKey{kind: nameKeyConstant, handle1: uint32(handle)}] = name //nolint:gosec // G115: handle is valid slice index
	}

	// Register global variable names
	for handle := range w.module.GlobalVariables {
		global := &w.module.GlobalVariables[handle]
		var baseName string
		if global.Name != "" {
			baseName = global.Name
		} else {
			baseName = fmt.Sprintf("global_%d", handle)
		}
		name := w.namer.call(baseName)
		w.names[nameKey{kind: nameKeyGlobalVariable, handle1: uint32(handle)}] = name //nolint:gosec // G115: handle is valid slice index
	}

	// Register function names
	for handle := range w.module.Functions {
		fn := &w.module.Functions[handle]
		var baseName string
		if fn.Name != "" {
			baseName = fn.Name
		} else {
			baseName = fmt.Sprintf("function_%d", handle)
		}
		name := w.namer.call(baseName)
		w.names[nameKey{kind: nameKeyFunction, handle1: uint32(handle)}] = name //nolint:gosec // G115: handle is valid slice index

		// Register function argument names
		for argIdx, arg := range fn.Arguments {
			argName := arg.Name
			if argName == "" {
				argName = fmt.Sprintf("arg_%d", argIdx)
			}
			w.names[nameKey{kind: nameKeyFunctionArgument, handle1: uint32(handle), handle2: uint32(argIdx)}] = Escape(argName) //nolint:gosec // G115: handle is valid slice index
		}
	}

	// Register entry point names
	for epIdx := range w.module.EntryPoints {
		ep := &w.module.EntryPoints[epIdx]
		// Entry point function is named by shader type convention
		name := fmt.Sprintf("%s_main", ShaderStageToHLSL(ep.Stage))
		if w.options.EntryPoint != "" && ep.Name != w.options.EntryPoint {
			continue
		}
		w.names[nameKey{kind: nameKeyEntryPoint, handle1: uint32(epIdx)}] = name //nolint:gosec // G115: epIdx is valid slice index
		w.entryPointNames[ep.Name] = name
	}

	return nil
}

// NOTE: writeTypes, writeConstants, writeConstantValue, writeScalarValue,
// writeCompositeValue, writeGlobalVariables are implemented in types.go

// getBindTarget looks up or generates a bind target for a resource binding.
func (w *Writer) getBindTarget(binding *ir.ResourceBinding) BindTarget {
	if binding == nil {
		return DefaultBindTarget()
	}

	key := ResourceBinding{Group: binding.Group, Binding: binding.Binding}
	if target, ok := w.options.BindingMap[key]; ok {
		return target
	}

	// Auto-generate binding if allowed
	if w.options.FakeMissingBindings {
		space := uint8(0)
		if binding.Group <= 255 {
			space = uint8(binding.Group)
		}
		return BindTarget{
			Space:    space,
			Register: binding.Binding,
		}
	}

	return DefaultBindTarget()
}

// writeHelperFunctions writes any needed polyfill functions.
func (w *Writer) writeHelperFunctions() {
	if w.needsModHelper {
		w.writeLine("// Safe modulo helper (truncated division semantics)")
		w.writeLine("int %s(int a, int b) {", NagaModFunction)
		w.pushIndent()
		w.writeLine("return a - b * (a / b);")
		w.popIndent()
		w.writeLine("}")
		w.writeLine("")
		w.helperFunctions = append(w.helperFunctions, NagaModFunction)
	}

	if w.needsDivHelper {
		w.writeLine("// Safe division helper (handles zero divisor)")
		w.writeLine("int %s(int a, int b) {", NagaDivFunction)
		w.pushIndent()
		w.writeLine("return b != 0 ? a / b : 0;")
		w.popIndent()
		w.writeLine("}")
		w.writeLine("")
		w.helperFunctions = append(w.helperFunctions, NagaDivFunction)
	}

	if w.needsAbsHelper {
		w.writeLine("// Safe abs helper (handles INT_MIN)")
		w.writeLine("int %s(int v) {", NagaAbsFunction)
		w.pushIndent()
		w.writeLine("return v >= 0 ? v : (v == -2147483648 ? 2147483647 : -v);")
		w.popIndent()
		w.writeLine("}")
		w.writeLine("")
		w.helperFunctions = append(w.helperFunctions, NagaAbsFunction)
	}
}

// writeFunctions writes regular function definitions.
// Entry point functions are skipped here â€” they are written by writeEntryPoints
// with proper I/O structs and semantics.
func (w *Writer) writeFunctions() error {
	for handle := range w.module.Functions {
		if w.isEntryPointFunction(ir.FunctionHandle(handle)) { //nolint:gosec // G115: handle is valid slice index
			continue
		}
		fn := &w.module.Functions[handle]
		if err := w.writeFunction(ir.FunctionHandle(handle), fn); err != nil { //nolint:gosec // G115: handle is valid slice index
			return err
		}
	}
	return nil
}

// writeFunction writes a single function definition.
func (w *Writer) writeFunction(handle ir.FunctionHandle, fn *ir.Function) error {
	w.currentFunction = fn
	w.currentFuncHandle = handle
	w.localNames = make(map[uint32]string)
	w.namedExpressions = make(map[ir.ExpressionHandle]string)

	name := w.names[nameKey{kind: nameKeyFunction, handle1: uint32(handle)}]

	// Return type
	var returnType string
	if fn.Result != nil {
		returnType = w.getTypeName(fn.Result.Type)
	} else {
		returnType = hlslVoidType
	}

	// Arguments
	args := make([]string, 0, len(fn.Arguments))
	for argIdx, arg := range fn.Arguments {
		argName := w.names[nameKey{kind: nameKeyFunctionArgument, handle1: uint32(handle), handle2: uint32(argIdx)}] //nolint:gosec // G115: argIdx is bounded by slice length
		argType := w.getTypeName(arg.Type)
		args = append(args, fmt.Sprintf("%s %s", argType, argName))
	}

	w.writeLine("%s %s(%s) {", returnType, name, strings.Join(args, ", "))
	w.pushIndent()

	// Write function body (local variables + statements)
	if err := w.writeFunctionBody(fn); err != nil {
		w.popIndent()
		w.currentFunction = nil
		return err
	}

	w.popIndent()
	w.writeLine("}")
	w.writeLine("")

	w.currentFunction = nil
	return nil
}

// writeEntryPoints writes entry point functions.
func (w *Writer) writeEntryPoints() error {
	for epIdx := range w.module.EntryPoints {
		ep := &w.module.EntryPoints[epIdx]
		// Skip if not the selected entry point
		if w.options.EntryPoint != "" && ep.Name != w.options.EntryPoint {
			continue
		}

		if err := w.writeEntryPointWithIO(epIdx, ep); err != nil {
			return err
		}
	}
	return nil
}

// Output helpers

// writeLine writes a line with indentation and newline.
//
//nolint:goprintffuncname
func (w *Writer) writeLine(format string, args ...any) {
	w.writeIndent()
	if len(args) == 0 {
		w.out.WriteString(format)
	} else {
		fmt.Fprintf(&w.out, format, args...)
	}
	w.out.WriteByte('\n')
}

// writeIndent writes the current indentation.
func (w *Writer) writeIndent() {
	for i := 0; i < w.indent; i++ {
		w.out.WriteString("    ")
	}
}

// pushIndent increases indentation.
func (w *Writer) pushIndent() {
	w.indent++
}

// popIndent decreases indentation.
func (w *Writer) popIndent() {
	if w.indent > 0 {
		w.indent--
	}
}

// NOTE: getTypeName, typeToHLSL, float32FromBits are implemented in types.go
