// Copyright 2025 The GoGPU Authors
// SPDX-License-Identifier: MIT

package hlsl

import (
	"fmt"
	"math"
	"strings"

	"github.com/gogpu/naga/ir"
)

// nameKey identifies an IR entity for name lookup.
type nameKey struct {
	kind    nameKeyKind
	handle1 uint32
	handle2 uint32
}

// nameKeyKind identifies the type of IR entity.
type nameKeyKind uint8

const (
	nameKeyType nameKeyKind = iota
	nameKeyStructMember
	nameKeyConstant
	nameKeyGlobalVariable
	nameKeyFunction
	nameKeyFunctionArgument
	nameKeyEntryPoint
	nameKeyLocal
)

// Writer generates HLSL source code from IR.
type Writer struct {
	module  *ir.Module
	options *Options

	// Output buffer
	out strings.Builder

	// Current indentation level
	indent int

	// Name management
	names map[nameKey]string
	namer *namer

	// Type tracking
	typeNames map[ir.TypeHandle]string

	// Function context (set during function writing)
	currentFunction   *ir.Function
	currentFuncHandle ir.FunctionHandle
	localNames        map[uint32]string
	namedExpressions  map[ir.ExpressionHandle]string

	// Output tracking
	entryPointNames     map[string]string
	registerBindings    map[string]string
	helperFunctions     []string
	usedFeatures        FeatureFlags
	requiredShaderModel ShaderModel

	// Helper function flags
	needsModHelper bool
	needsDivHelper bool
	needsAbsHelper bool
}

// newWriter creates a new HLSL writer.
func newWriter(module *ir.Module, options *Options) *Writer {
	return &Writer{
		module:              module,
		options:             options,
		names:               make(map[nameKey]string),
		namer:               newNamer(),
		typeNames:           make(map[ir.TypeHandle]string),
		entryPointNames:     make(map[string]string),
		registerBindings:    make(map[string]string),
		namedExpressions:    make(map[ir.ExpressionHandle]string),
		requiredShaderModel: options.ShaderModel,
	}
}

// String returns the generated HLSL source code.
func (w *Writer) String() string {
	return w.out.String()
}

// writeModule generates HLSL code for the entire module.
func (w *Writer) writeModule() error {
	// 1. Write header comment
	w.writeHeader()

	// 2. Register all names
	if err := w.registerNames(); err != nil {
		return err
	}

	// 3. Write type definitions (structs)
	if err := w.writeTypes(); err != nil {
		return err
	}

	// 4. Write constants
	if err := w.writeConstants(); err != nil {
		return err
	}

	// 5. Write global variables (cbuffers, textures, etc.)
	if err := w.writeGlobalVariables(); err != nil {
		return err
	}

	// 6. Write helper functions if needed
	w.writeHelperFunctions()

	// 7. Write regular functions
	if err := w.writeFunctions(); err != nil {
		return err
	}

	// 8. Write entry points
	return w.writeEntryPoints()
}

// writeHeader writes an optional header comment.
func (w *Writer) writeHeader() {
	w.writeLine("// Generated by naga HLSL backend")
	w.writeLine("// Target: %s", w.options.ShaderModel.String())
	w.writeLine("")
}

// registerNames assigns unique names to all IR entities.
//
//nolint:gocognit // Name registration requires handling all IR entity types
func (w *Writer) registerNames() error {
	// Register type names
	for handle := range w.module.Types {
		typ := &w.module.Types[handle]
		var baseName string
		if typ.Name != "" {
			baseName = typ.Name
		} else {
			baseName = fmt.Sprintf("type_%d", handle)
		}
		name := w.namer.call(baseName)
		w.names[nameKey{kind: nameKeyType, handle1: uint32(handle)}] = name //nolint:gosec // G115: handle is valid slice index
		w.typeNames[ir.TypeHandle(handle)] = name                           //nolint:gosec // G115: handle is valid slice index

		// Register struct member names
		if st, ok := typ.Inner.(ir.StructType); ok {
			for memberIdx, member := range st.Members {
				memberName := member.Name
				if memberName == "" {
					memberName = fmt.Sprintf("member_%d", memberIdx)
				}
				w.names[nameKey{kind: nameKeyStructMember, handle1: uint32(handle), handle2: uint32(memberIdx)}] = Escape(memberName) //nolint:gosec // G115: handle is valid slice index
			}
		}
	}

	// Register constant names
	for handle := range w.module.Constants {
		constant := &w.module.Constants[handle]
		var baseName string
		if constant.Name != "" {
			baseName = constant.Name
		} else {
			baseName = fmt.Sprintf("const_%d", handle)
		}
		name := w.namer.call(baseName)
		w.names[nameKey{kind: nameKeyConstant, handle1: uint32(handle)}] = name //nolint:gosec // G115: handle is valid slice index
	}

	// Register global variable names
	for handle := range w.module.GlobalVariables {
		global := &w.module.GlobalVariables[handle]
		var baseName string
		if global.Name != "" {
			baseName = global.Name
		} else {
			baseName = fmt.Sprintf("global_%d", handle)
		}
		name := w.namer.call(baseName)
		w.names[nameKey{kind: nameKeyGlobalVariable, handle1: uint32(handle)}] = name //nolint:gosec // G115: handle is valid slice index
	}

	// Register function names
	for handle := range w.module.Functions {
		fn := &w.module.Functions[handle]
		var baseName string
		if fn.Name != "" {
			baseName = fn.Name
		} else {
			baseName = fmt.Sprintf("function_%d", handle)
		}
		name := w.namer.call(baseName)
		w.names[nameKey{kind: nameKeyFunction, handle1: uint32(handle)}] = name //nolint:gosec // G115: handle is valid slice index

		// Register function argument names
		for argIdx, arg := range fn.Arguments {
			argName := arg.Name
			if argName == "" {
				argName = fmt.Sprintf("arg_%d", argIdx)
			}
			w.names[nameKey{kind: nameKeyFunctionArgument, handle1: uint32(handle), handle2: uint32(argIdx)}] = Escape(argName) //nolint:gosec // G115: handle is valid slice index
		}
	}

	// Register entry point names
	for epIdx := range w.module.EntryPoints {
		ep := &w.module.EntryPoints[epIdx]
		// Entry point function is named by shader type convention
		name := fmt.Sprintf("%s_main", ShaderStageToHLSL(ep.Stage))
		if w.options.EntryPoint != "" && ep.Name != w.options.EntryPoint {
			continue
		}
		w.names[nameKey{kind: nameKeyEntryPoint, handle1: uint32(epIdx)}] = name //nolint:gosec // G115: epIdx is valid slice index
		w.entryPointNames[ep.Name] = name
	}

	return nil
}

// writeTypes writes struct type definitions.
func (w *Writer) writeTypes() error {
	for handle := range w.module.Types {
		typ := &w.module.Types[handle]
		st, ok := typ.Inner.(ir.StructType)
		if !ok {
			continue
		}

		typeName := w.typeNames[ir.TypeHandle(handle)] //nolint:gosec // G115: handle is valid slice index
		w.writeLine("struct %s {", typeName)
		w.pushIndent()

		for memberIdx, member := range st.Members {
			memberType := w.getTypeName(member.Type)
			memberName := w.names[nameKey{kind: nameKeyStructMember, handle1: uint32(handle), handle2: uint32(memberIdx)}] //nolint:gosec // G115: handle is valid slice index
			w.writeLine("%s %s;", memberType, memberName)
		}

		w.popIndent()
		w.writeLine("};")
		w.writeLine("")
	}
	return nil
}

// writeConstants writes constant definitions.
func (w *Writer) writeConstants() error {
	for handle := range w.module.Constants {
		constant := &w.module.Constants[handle]
		name := w.names[nameKey{kind: nameKeyConstant, handle1: uint32(handle)}] //nolint:gosec // G115: handle is valid slice index
		typeName := w.getTypeName(constant.Type)
		value := w.writeConstantValue(constant)
		w.writeLine("static const %s %s = %s;", typeName, name, value)
	}
	if len(w.module.Constants) > 0 {
		w.writeLine("")
	}
	return nil
}

// writeConstantValue returns the HLSL representation of a constant value.
func (w *Writer) writeConstantValue(constant *ir.Constant) string {
	switch v := constant.Value.(type) {
	case ir.ScalarValue:
		return w.writeScalarValue(v)
	case ir.CompositeValue:
		return w.writeCompositeValue(v, constant.Type)
	default:
		return "0" // Unknown value type
	}
}

// writeScalarValue returns the HLSL representation of a scalar value.
func (w *Writer) writeScalarValue(v ir.ScalarValue) string {
	switch v.Kind {
	case ir.ScalarBool:
		if v.Bits != 0 {
			return "true"
		}
		return "false"
	case ir.ScalarSint:
		return fmt.Sprintf("%d", int32(v.Bits))
	case ir.ScalarUint:
		return fmt.Sprintf("%du", uint32(v.Bits))
	case ir.ScalarFloat:
		// Default to 32-bit float representation
		return fmt.Sprintf("%g", float32FromBits(uint32(v.Bits)))
	default:
		return "0"
	}
}

// writeCompositeValue returns the HLSL representation of a composite value.
func (w *Writer) writeCompositeValue(v ir.CompositeValue, typeHandle ir.TypeHandle) string {
	typeName := w.getTypeName(typeHandle)
	var components []string
	for _, compHandle := range v.Components {
		if int(compHandle) < len(w.module.Constants) {
			constant := &w.module.Constants[compHandle]
			components = append(components, w.writeConstantValue(constant))
		} else {
			components = append(components, "0")
		}
	}
	return fmt.Sprintf("%s(%s)", typeName, strings.Join(components, ", "))
}

// writeGlobalVariables writes global resource declarations.
func (w *Writer) writeGlobalVariables() error {
	for handle := range w.module.GlobalVariables {
		global := &w.module.GlobalVariables[handle]
		name := w.names[nameKey{kind: nameKeyGlobalVariable, handle1: uint32(handle)}] //nolint:gosec // G115: handle is valid slice index
		typeName := w.getTypeName(global.Type)

		switch global.Space {
		case ir.SpaceUniform:
			w.writeUniformVariable(name, typeName, global)
		case ir.SpaceStorage:
			w.writeStorageVariable(name, typeName, global)
		case ir.SpaceWorkGroup:
			w.writeLine("groupshared %s %s;", typeName, name)
		case ir.SpacePrivate:
			w.writeLine("static %s %s;", typeName, name)
		default:
			w.writeLine("%s %s;", typeName, name)
		}
	}
	if len(w.module.GlobalVariables) > 0 {
		w.writeLine("")
	}
	return nil
}

// writeUniformVariable writes a cbuffer or constant buffer declaration.
func (w *Writer) writeUniformVariable(name, typeName string, global *ir.GlobalVariable) {
	if global.Binding != nil {
		binding := w.getBindTarget(global.Binding)
		w.writeLine("cbuffer %s_cbuffer : register(b%d, space%d) {", name, binding.Register, binding.Space)
		w.pushIndent()
		w.writeLine("%s %s;", typeName, name)
		w.popIndent()
		w.writeLine("};")
		w.registerBindings[name] = fmt.Sprintf("register(b%d, space%d)", binding.Register, binding.Space)
	} else {
		w.writeLine("cbuffer %s_cbuffer {", name)
		w.pushIndent()
		w.writeLine("%s %s;", typeName, name)
		w.popIndent()
		w.writeLine("};")
	}
}

// writeStorageVariable writes an RW buffer declaration.
func (w *Writer) writeStorageVariable(name, typeName string, global *ir.GlobalVariable) {
	if global.Binding != nil {
		binding := w.getBindTarget(global.Binding)
		w.writeLine("RWStructuredBuffer<%s> %s : register(u%d, space%d);", typeName, name, binding.Register, binding.Space)
		w.registerBindings[name] = fmt.Sprintf("register(u%d, space%d)", binding.Register, binding.Space)
	} else {
		w.writeLine("RWStructuredBuffer<%s> %s;", typeName, name)
	}
}

// getBindTarget looks up or generates a bind target for a resource binding.
func (w *Writer) getBindTarget(binding *ir.ResourceBinding) BindTarget {
	if binding == nil {
		return DefaultBindTarget()
	}

	key := ResourceBinding{Group: binding.Group, Binding: binding.Binding}
	if target, ok := w.options.BindingMap[key]; ok {
		return target
	}

	// Auto-generate binding if allowed
	if w.options.FakeMissingBindings {
		space := uint8(0)
		if binding.Group <= 255 {
			space = uint8(binding.Group)
		}
		return BindTarget{
			Space:    space,
			Register: binding.Binding,
		}
	}

	return DefaultBindTarget()
}

// writeHelperFunctions writes any needed polyfill functions.
func (w *Writer) writeHelperFunctions() {
	if w.needsModHelper {
		w.writeLine("// Safe modulo helper (truncated division semantics)")
		w.writeLine("int %s(int a, int b) {", NagaModFunction)
		w.pushIndent()
		w.writeLine("return a - b * (a / b);")
		w.popIndent()
		w.writeLine("}")
		w.writeLine("")
		w.helperFunctions = append(w.helperFunctions, NagaModFunction)
	}

	if w.needsDivHelper {
		w.writeLine("// Safe division helper (handles zero divisor)")
		w.writeLine("int %s(int a, int b) {", NagaDivFunction)
		w.pushIndent()
		w.writeLine("return b != 0 ? a / b : 0;")
		w.popIndent()
		w.writeLine("}")
		w.writeLine("")
		w.helperFunctions = append(w.helperFunctions, NagaDivFunction)
	}

	if w.needsAbsHelper {
		w.writeLine("// Safe abs helper (handles INT_MIN)")
		w.writeLine("int %s(int v) {", NagaAbsFunction)
		w.pushIndent()
		w.writeLine("return v >= 0 ? v : (v == -2147483648 ? 2147483647 : -v);")
		w.popIndent()
		w.writeLine("}")
		w.writeLine("")
		w.helperFunctions = append(w.helperFunctions, NagaAbsFunction)
	}
}

// writeFunctions writes regular function definitions.
func (w *Writer) writeFunctions() error {
	for handle := range w.module.Functions {
		fn := &w.module.Functions[handle]
		if err := w.writeFunction(ir.FunctionHandle(handle), fn); err != nil { //nolint:gosec // G115: handle is valid slice index
			return err
		}
	}
	return nil
}

// writeFunction writes a single function definition.
func (w *Writer) writeFunction(handle ir.FunctionHandle, fn *ir.Function) error {
	w.currentFunction = fn
	w.currentFuncHandle = handle
	w.localNames = make(map[uint32]string)

	name := w.names[nameKey{kind: nameKeyFunction, handle1: uint32(handle)}]

	// Return type
	var returnType string
	if fn.Result != nil {
		returnType = w.getTypeName(fn.Result.Type)
	} else {
		returnType = "void"
	}

	// Arguments
	args := make([]string, 0, len(fn.Arguments))
	for argIdx, arg := range fn.Arguments {
		argName := w.names[nameKey{kind: nameKeyFunctionArgument, handle1: uint32(handle), handle2: uint32(argIdx)}] //nolint:gosec // G115: argIdx is bounded by slice length
		argType := w.getTypeName(arg.Type)
		args = append(args, fmt.Sprintf("%s %s", argType, argName))
	}

	w.writeLine("%s %s(%s) {", returnType, name, strings.Join(args, ", "))
	w.pushIndent()

	// Write local variables
	for localIdx, local := range fn.LocalVars {
		localName := w.namer.call(local.Name)
		w.localNames[uint32(localIdx)] = localName //nolint:gosec // G115: localIdx is valid slice index
		localType := w.getTypeName(local.Type)
		w.writeLine("%s %s;", localType, localName)
	}

	// Write function body (placeholder - full implementation in later phases)
	w.writeLine("// Function body (to be implemented)")

	w.popIndent()
	w.writeLine("}")
	w.writeLine("")

	w.currentFunction = nil
	return nil
}

// writeEntryPoints writes entry point functions.
func (w *Writer) writeEntryPoints() error {
	for epIdx := range w.module.EntryPoints {
		ep := &w.module.EntryPoints[epIdx]
		// Skip if not the selected entry point
		if w.options.EntryPoint != "" && ep.Name != w.options.EntryPoint {
			continue
		}

		if err := w.writeEntryPoint(epIdx, ep); err != nil {
			return err
		}
	}
	return nil
}

// writeEntryPoint writes a single entry point.
func (w *Writer) writeEntryPoint(epIdx int, ep *ir.EntryPoint) error {
	// Look up actual function from handle
	fn := &w.module.Functions[ep.Function]
	w.currentFunction = fn
	w.localNames = make(map[uint32]string)

	name := w.names[nameKey{kind: nameKeyEntryPoint, handle1: uint32(epIdx)}] //nolint:gosec // G115: epIdx is valid slice index

	// Write compute shader attributes if needed
	if ep.Stage == ir.StageCompute {
		x, y, z := ep.Workgroup[0], ep.Workgroup[1], ep.Workgroup[2]
		if x == 0 {
			x = 1
		}
		if y == 0 {
			y = 1
		}
		if z == 0 {
			z = 1
		}
		w.writeLine("[numthreads(%d, %d, %d)]", x, y, z)
	}

	// Entry point signature
	w.writeLine("void %s() {", name)
	w.pushIndent()

	// Write local variables
	for localIdx, local := range fn.LocalVars {
		localName := w.namer.call(local.Name)
		w.localNames[uint32(localIdx)] = localName //nolint:gosec // G115: localIdx is valid slice index
		localType := w.getTypeName(local.Type)
		w.writeLine("%s %s;", localType, localName)
	}

	// Write function body (placeholder - full implementation in later phases)
	w.writeLine("// Entry point body (to be implemented)")

	w.popIndent()
	w.writeLine("}")

	w.currentFunction = nil
	return nil
}

// Output helpers

// writeLine writes a line with indentation and newline.
//
//nolint:goprintffuncname
func (w *Writer) writeLine(format string, args ...any) {
	w.writeIndent()
	if len(args) == 0 {
		w.out.WriteString(format)
	} else {
		fmt.Fprintf(&w.out, format, args...)
	}
	w.out.WriteByte('\n')
}

// writeIndent writes the current indentation.
func (w *Writer) writeIndent() {
	for i := 0; i < w.indent; i++ {
		w.out.WriteString("    ")
	}
}

// pushIndent increases indentation.
func (w *Writer) pushIndent() {
	w.indent++
}

// popIndent decreases indentation.
func (w *Writer) popIndent() {
	if w.indent > 0 {
		w.indent--
	}
}

// getTypeName returns the HLSL type name for a type handle.
func (w *Writer) getTypeName(handle ir.TypeHandle) string {
	if int(handle) >= len(w.module.Types) {
		return fmt.Sprintf("unknown_type_%d", handle)
	}

	typ := &w.module.Types[handle]
	return w.typeToHLSL(typ)
}

// typeToHLSL converts an IR type to HLSL type name.
func (w *Writer) typeToHLSL(typ *ir.Type) string {
	switch inner := typ.Inner.(type) {
	case ir.ScalarType:
		return ScalarToHLSL(inner)
	case ir.VectorType:
		return VectorToHLSL(inner)
	case ir.MatrixType:
		return MatrixToHLSL(inner)
	case ir.ArrayType:
		elemType := w.getTypeName(inner.Base)
		if inner.Size.Constant != nil {
			return fmt.Sprintf("%s[%d]", elemType, *inner.Size.Constant)
		}
		return elemType + "[]"
	case ir.StructType:
		if typ.Name != "" {
			return Escape(typ.Name)
		}
		return w.typeNames[ir.TypeHandle(0)] // Fallback
	case ir.PointerType:
		return w.getTypeName(inner.Base) // HLSL doesn't have explicit pointers
	case ir.SamplerType:
		return SamplerToHLSL(inner.Comparison)
	case ir.ImageType:
		return ImageToHLSL(inner, false)
	default:
		return "unknown"
	}
}

// float32FromBits converts uint32 bits to float32.
func float32FromBits(bits uint32) float32 {
	return math.Float32frombits(bits)
}
