package msl

// reservedWords contains all MSL and C++ reserved words.
// These identifiers must be escaped or renamed when generating MSL code.
var reservedWords = map[string]struct{}{
	// C++ keywords
	"alignas":          {},
	"alignof":          {},
	"and":              {},
	"and_eq":           {},
	"asm":              {},
	"auto":             {},
	"bitand":           {},
	"bitor":            {},
	"bool":             {},
	"break":            {},
	"case":             {},
	"catch":            {},
	"char":             {},
	"char16_t":         {},
	"char32_t":         {},
	"class":            {},
	"compl":            {},
	"const":            {},
	"const_cast":       {},
	"constexpr":        {},
	"continue":         {},
	"decltype":         {},
	"default":          {},
	"delete":           {},
	"do":               {},
	"double":           {},
	"dynamic_cast":     {},
	"else":             {},
	"enum":             {},
	"explicit":         {},
	"export":           {},
	"extern":           {},
	"false":            {},
	"final":            {},
	"float":            {},
	"for":              {},
	"friend":           {},
	"goto":             {},
	"if":               {},
	"inline":           {},
	"int":              {},
	"long":             {},
	"mutable":          {},
	"namespace":        {},
	"new":              {},
	"noexcept":         {},
	"not":              {},
	"not_eq":           {},
	"nullptr":          {},
	"operator":         {},
	"or":               {},
	"or_eq":            {},
	"override":         {},
	"private":          {},
	"protected":        {},
	"public":           {},
	"register":         {},
	"reinterpret_cast": {},
	"return":           {},
	"short":            {},
	"signed":           {},
	"sizeof":           {},
	"static":           {},
	"static_assert":    {},
	"static_cast":      {},
	"struct":           {},
	"switch":           {},
	"template":         {},
	"this":             {},
	"thread_local":     {},
	"throw":            {},
	"true":             {},
	"try":              {},
	"typedef":          {},
	"typeid":           {},
	"typename":         {},
	"union":            {},
	"unsigned":         {},
	"using":            {},
	"virtual":          {},
	"void":             {},
	"volatile":         {},
	"wchar_t":          {},
	"while":            {},
	"xor":              {},
	"xor_eq":           {},

	// MSL scalar types
	"char2":     {},
	"char3":     {},
	"char4":     {},
	"uchar":     {},
	"uchar2":    {},
	"uchar3":    {},
	"uchar4":    {},
	"short2":    {},
	"short3":    {},
	"short4":    {},
	"ushort":    {},
	"ushort2":   {},
	"ushort3":   {},
	"ushort4":   {},
	"int2":      {},
	"int3":      {},
	"int4":      {},
	"uint":      {},
	"uint2":     {},
	"uint3":     {},
	"uint4":     {},
	"long2":     {},
	"long3":     {},
	"long4":     {},
	"ulong":     {},
	"ulong2":    {},
	"ulong3":    {},
	"ulong4":    {},
	"half":      {},
	"half2":     {},
	"half3":     {},
	"half4":     {},
	"float2":    {},
	"float3":    {},
	"float4":    {},
	"bfloat":    {},
	"bfloat2":   {},
	"bfloat3":   {},
	"bfloat4":   {},
	"size_t":    {},
	"ptrdiff_t": {},

	// MSL packed vector types
	"packed_char2":   {},
	"packed_char3":   {},
	"packed_char4":   {},
	"packed_uchar2":  {},
	"packed_uchar3":  {},
	"packed_uchar4":  {},
	"packed_short2":  {},
	"packed_short3":  {},
	"packed_short4":  {},
	"packed_ushort2": {},
	"packed_ushort3": {},
	"packed_ushort4": {},
	"packed_int2":    {},
	"packed_int3":    {},
	"packed_int4":    {},
	"packed_uint2":   {},
	"packed_uint3":   {},
	"packed_uint4":   {},
	"packed_half2":   {},
	"packed_half3":   {},
	"packed_half4":   {},
	"packed_float2":  {},
	"packed_float3":  {},
	"packed_float4":  {},

	// MSL matrix types
	"float2x2": {},
	"float2x3": {},
	"float2x4": {},
	"float3x2": {},
	"float3x3": {},
	"float3x4": {},
	"float4x2": {},
	"float4x3": {},
	"float4x4": {},
	"half2x2":  {},
	"half2x3":  {},
	"half2x4":  {},
	"half3x2":  {},
	"half3x3":  {},
	"half3x4":  {},
	"half4x2":  {},
	"half4x3":  {},
	"half4x4":  {},

	// MSL address spaces
	"device":      {},
	"constant":    {},
	"thread":      {},
	"threadgroup": {},

	// MSL stage keywords
	"vertex":   {},
	"fragment": {},
	"kernel":   {},

	// MSL atomic types
	"atomic":      {},
	"atomic_int":  {},
	"atomic_uint": {},
	"atomic_bool": {},

	// Metal namespace and important identifiers
	"metal":  {},
	"access": {},
	"array":  {},
	"simd":   {},

	// Math constants
	"M_E_F":        {},
	"M_LOG2E_F":    {},
	"M_LOG10E_F":   {},
	"M_LN2_F":      {},
	"M_LN10_F":     {},
	"M_PI_F":       {},
	"M_PI_2_F":     {},
	"M_PI_4_F":     {},
	"M_1_PI_F":     {},
	"M_2_PI_F":     {},
	"M_2_SQRTPI_F": {},
	"M_SQRT2_F":    {},
	"M_SQRT1_2_F":  {},
	"INFINITY":     {},
	"NAN":          {},

	// Naga helper function names (reserved to avoid conflicts)
	"_naga_div":             {},
	"_naga_mod":             {},
	"_naga_modf":            {},
	"_naga_frexp":           {},
	"_naga_atomic_cmp_exch": {},
	"_naga_int_dot":         {},
	"_mslBufferSizes":       {},

	// Common variable names that might conflict
	"in":       {},
	"out":      {},
	"inout":    {},
	"main":     {},
	"main0":    {},
	"uniform":  {},
	"buffer":   {},
	"texture":  {},
	"sampler":  {},
	"position": {},
	"color":    {},
	"normal":   {},
}

// isReserved checks if an identifier is a reserved word.
func isReserved(name string) bool {
	_, ok := reservedWords[name]
	return ok
}

// escapeName escapes a name if it's reserved, by adding an underscore suffix.
func escapeName(name string) string {
	if isReserved(name) {
		return name + "_"
	}
	return name
}
